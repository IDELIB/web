<HTML>
<HEAD>
<TITLE>Socket FAQ</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#408080" ALINK="#FF0000">
<BASEFONT SIZE=4 COLOR="#000080" FACE="Times New Roman">
<CENTER><H1>Socket FAQ ( Frequently Asked Questions )</H1></CENTER><P>
<A HREF="../index.html">[Return]</A><BR>
<HR>
<DL>
<!--------------------------------------------------------------------------------------------->

<CENTER><H4>【掲載日】　1999/10/11 </H4></CENTER>

<DT><H4>【質問】</H4>
<DD>たまに、受信したレコードの最後が途中で切れていることがあります。どうしてでしょうか？

<DT><H4>【回答】</H4>
<DD>SNA であればフレーム単位の伝送なのでこのようなことは起こりませんが、TCPIP は<FONT COLOR="#ff0080">バイト単位</FONT>で伝送を行います。
<BR>そのため、伝送中にレコードが複数のパケットに分割され、受信したバッファーにレコードの途中までしか入っていない事が
あります。
<P>つまり、400 バイトのレコードを send() し、400 バイトの Buffer 長を指定して recv() を行ったとしても、１回の recv()
で、400 バイト全てのデータがとれる保証はありません。
<P>800 バイトの Buffer 長を指定して recv() を行うと、２回分のレコードが１回の recv() で受信できるかもしれません。

<P>固定長データの送受信ならば、受信したあとに足りないバイト数分の recv() を再度実行するようにコーディングしてください。

<P>可変長データの送受信ならは、データの終わりを判別出来るような文字を最後につけましょう。
( TCPIP の多くのアプリケーション（ftp,telnet,smtp...）は、レコードの終わりを CRLF で判別しています。)

<DT><P><HR>
<!--------------------------------------------------------------------------------------------->
<CENTER><H4>【掲載日】　1999/10/5 </H4></CENTER>

<DT><H4>【質問】</H4>
<DD>サーバーアプリケーションで使用する子プロセス（BCI）などでソケットをcloseしても、終了待機でソケットが残ってしまう。
同じロジックで、バッチ／対話ジョブだと正常にクローズできる。なぜ？

<DT><H4>【回答】</H4>
<DD>「終了待機」の状態は、ローカルのソケットがクローズ処理（FIN送信）を行っていないと発生します。

<P>spawn()関数を使用したプロセスでは、親プロセスと子プロセス間で、ファイルのディスクリプターを共有できます。
<P>共有されたディスクリプターは、共有しているプロセスがあると、close()してもクローズ処理が延期されます。

<P>上記のケースでは、親プロセスがソケットのディスクリプターを共有しているので、子プロセスでのclose()はすぐには処理されません。
そのため、ローカル・ソケットから FIN が送られず、上記の様な現象になります。共有している親プロセスの終了と同時にすべての
ソケットがクローズされるでしょう。

<DT><P><HR>
<!--------------------------------------------------------------------------------------------->
<CENTER><H4>【掲載日】　1999/10/3 </H4></CENTER>

<DT><H4>【質問】</H4>
<DD>宛先アドレスに 255.255.255.255 のアドレスを指定すると、呼出しエラーになってしまいます。

<DT><H4>【回答】</H4>
<DD>255.255.255.255 はブロードキャストアドレスになりますので、他のアドレスと扱いが異なります。

<P>そのため、このアドレスを使用すると

<P><UL><FONT COLOR="#ff0080">[EACCES]</FONT>
<UL>
    許可されませんでした。<BR>
    プロセスに、宛先アドレスに対する適切な特権がありません。
</UL>
</UL>

<P>というエラーが発生してしまいます。

<P>この辺の実装はプラットフォーム毎に差異のあるところで、特に他のプラットフォームからの移植では問題となるでしょう。

<P>ＡＳ／４００では、255.255.255.255のアドレスは、以下のソケットオプションの設定により許可されます。

<P><UL><FONT COLOR="#ff0080">SO_BROADCAST</FONT></UL>

<P>このオプション設定を行うと、上記エラーは発生しなくなりますが、実際にネットワークに出力されるデータが他のプラットフォーム
の解釈と同じとはかぎりません。

<P>ＡＳ／４００は INADDR_BROADCAST（255.255.255.255 / 0xFFFFFFFF)宛先の解釈に、そのソケットの bind IPの有無／
使用するインターフェースのサブネット／ソケットのタイプ／同報通信の有無　などからネットワークに送出するデータを作成します。

<P>ですから、ＡＳ／４００の場合、ネットワークに送出されるデータが、実際に255.255.255.255のIPアドレスを持つことはまずないでしょう。
<P>多くの場合、送出を許可されない、または、宛先IPアドレス 10.255.255.255 宛先MACアドレス 0xFFFFFFFF をもつパケットの
送出という結果になるでしょう。
<BR>(10 はネットワークアドレス + 255.255.255 はブロードキャスト = 10 のネットワーク全体へのブロードキャストの意味）

<P>あるいは、別の手段として、<FONT COLOR="#ff0080">SOCK_RAW</FONT> を指定したソケットで、IPデータグラムの組み立てを
ユーザープログラムで行う方法が考えられます。
<P>しかし、実際に私のテストしたところこでは、上記内容のＩＰデータグラムを作成して送出しようとするとエラーになります。
<BR>エラーの内容からして、おそらくＡＳ／４００のマイクロコードレベルで拒否されてしまっているのでしょう。

<DT><H4>【私見】</H4>
<DD> 255.255.255.255 や その他の特殊アドレスなどをＯＳが制限しているのは、ネットワークの安全性という観点で十分な
理由があると思います。もし、実際に 255.255.255.255 の宛先ＩＰにパケットを送ったとしたら、最悪の場合ネットワーク上の
すべてのホストから返信があるかもしれません。この状況はおそらくネットワークダウンを引き起こすでしょう。

<P>現状のＡＳ／４００の使われ方は商用サーバーとしての位置づけであり、上記の様な制限をかけること、あるいは、
サポートしていないことは、当然なのかもしれません。

<P>特殊アドレスを必要とするのは、主に実験的なネットワークテストであり、そのプラットフォーム OS で AS/400 が選ばれることは
ことはまずないでしょう。この様な用途にはやはり、unix （特にカーネルソースが公開されている unix ）が最適です。
なんでもありですもんね。

<!--------------------------------------------------------------------------------------------->
<DT><P><HR>
<CENTER><H4>【掲載日】　1999/10/5 </H4></CENTER>

<DT><H4>【質問】</H4>
<DD>ソケットの状態が、TIME_WAIT (時間待機）以外のステータスとなり、PORTの開放に時間がかかることがあります。確実に終了する方法は？

<DT><H4>【回答】</H4>
<DD>いろいろな方法が考えられるのでしょうが、ここではシャットダウン関数を使用してのクローズを紹介します。

<P>シャットダウン関数はクローズ関数と違い、送信／受信を別々に禁止出来ます。

<P>クローズしたい側は、まずソケットの送信を禁止し自分の送信バッファーを空にします。その後、相手からのクローズ要求(FIN)
を recv関数 で待ちます。受信バッファーが空になり、相手もクローズしたのを確認後に、送信を禁止しクローズ処理します。

<P>以下に、シャットダウン関数を使用したサンプルコード例を掲載します。

<DT><H4>【例】</H4>
<DD><PRE>
int how;

/* まず、ソケットの送信を停止する */
  how = 1;
  rc = shutdown(sd, how);

/* 相手のクローズを待つ */
  rc = recv(sd, buf ,buflen, 0);
  if (rc > 0) {
    printf("データが破棄されました");
  } 

/* そして、ソケットの受信も停止する */
  how = 2; /* 0（送受信の禁止）でもＯＫ */
  rc = shutdown(sd, how);

/* 安心してクローズ */
  rc = close(sd);
</PRE>

<P>上記サンプルコードでは、[EPIPE]のエラーの発生を無視したいため、戻りコードの確認をあえて省略しています。
<P>上記の recv() のあとに戻り値を確認しているのは、もしデータが正常に受信されてしまった場合に警告をだす為です。
ここの recv()では、-1 or 0 の戻りを期待しています。

<DT><P><HR>
<!--------------------------------------------------------------------------------------------->
<DT><H4>【質問】</H4>
<DD>サーバーアプリケーションで使用する PORT 番号はどのようにして決めればよいのか？

<DT><H4>【回答】</H4>
<DD>TCPIP のアプケーションで予約されている PORT 番号（well-known-port　1〜1023）を避けて、65535までの
整数値から選びます。

<P>1024以降を使用する場合も、他のソケットアプリケーションとバッティングしないように気をつけましょう。

<P>サービステーブルに特定の名前で PORT 番号を登録し、プログラムで検索して PORTを使用するように作成すれば
PORT 番号の管理、変更が容易になるでしょう。PORTを検索する関数は、 getservbyname() / getservbyport() になります。

<DT><P><HR>

<DT><H4>【質問】</H4>
<DD>ＡＳ／４００でソケットのプログラムを作成したい、必要なものは？

<DT><H4>【回答】</H4>
<DD>必要なライセンスプログラムは以下のものです。
<UL>
<LI>ＯＳ／４００ TCPIP通信ユーティリティー
<UL>当たり前ですが、念の為</UL><P>
<LI>ＯＳ／４００オプション　”オープンネスインクルード”　バージョンで名称が異なります。
<UL>socket のヘッダーファイルが入っています。　</UL><P>
<LI>ILE-C コンパイラー
<UL>socket を正式にサポートしているのは、Ｃ言語だけです。</UL>
</UL>

<DT><P><HR>

<DT><H4>【質問】</H4>
<DD>ＡＳ／４００をサーバーとするプログラムを作成したいのですが、注意点は？

<DT><H4>【回答】</H4>
<DD>TCPのサーバーは通常デーモンとして常駐し、接続要求を受けると子プロセスを起動して処理します。
<BR>ＡＳ／４００のTCPソケットは、ほぼ BSDソケットとコンパチブルなので、通信自体は unix と同じと
考えて構わないでしょう。むしろ unix との差異は子プロセスの起動方法に大きく現れます。

<P>ＡＳ／４００は fork()関数をサポートしていません。その変わりは、spawn()関数になります。
<BR>スレッドはサポートされていますが、カーネルスレッドのサポートはバージョンV430以降になります。
このバージョン以前は、CPAツールキットが必要です。

<P>また、これらの機能はバージョンごとに拡張されているので、ターゲットリリースを指定した
コンパイルでは動作しないものと思っていたほうがよいでしょう。少なくとも利用するバージョンの
ＯＳ上でのコンパイルが必要です。内容によっては、ソースコードの修正や、コンパイルの方法も
異なります。
<DT><P><HR>

<DT><H4>【質問】</H4>
<DD>通信エラーでプログラムが終了してしまいました。原因を調べるにはどうすればよいのでしょうか？

<DT><H4>【回答】</H4>
<DD>プログラムで errno をひろってください。errno のエラー番号から内容を調べるには、
QSYSINC ライブラリーの SYS ソースファイルの ERRNO メンバーの中を検索してください。
<BR>エラー番号のマクロ定義とコメントが入っています。
<BR>コメントから判断するか、あるいは、マクロの名前でソケットのマニュアルを見て下さい。
<P>（注）ERRNOはＯＳ／４００バージョンによって異なる事がありますので、同じバージョンのものを
見て下さい。

<P>また、プログラムで perror() 関数を使用すると stderr にエラーの内容が日本語で表示されます。
<BR> perror() は、ソケット関数がエラーになった場合のみ呼ばれるようにしてください。

<H4>【例】</H4>
<PRE>
#include &LT;errno.h&GT;


/* コネクトが失敗した場合に理由を表示する */
  if((rc = connect(sd,(struct sockaddr *)&AMP;saddr, sizeof(saddr))) < 0){
    perror("connect() failed");
    exit(-1);
  }
</PRE>
<P>この例の場合、connect()関数が失敗すると、対話型ＪＯＢでは
<UL>”connect() failed Ｘ−失敗した理由−Ｘ”</UL>
<P>と画面に表示され、バッチＪＯＢでは、スプールファイルに上記が出力されます。

<DT><P><HR>

<DT><H4>【質問】</H4>
<DD>文字形式のＩＰアドレス” xxx.xxx.xxx.xxx "をＩＰアドレスに変換するにはどうすればよいのでしょうか？ 

<DT><H4>【回答】</H4>
<DD>inet_addr() 関数を使用します。戻り値が、ＩＰアドレスとなります。<BR>
<DD>ちなみに、反対は inet_ntoa() です。

<!--------------------------------------------------------------------------------------------->
<DT><P><HR>
<CENTER><H4>【更新日】　1999/10/3 </H4></CENTER>

<DT><H4>【質問】</H4>
<DD>ホスト名とＩＰアドレス” xxx.xxx.xxx.xxx "のどちらでも入力できるようにしたいのですがどうするばよいのでしょうか？

<DT><H4>【回答】</H4>
<DD>いろいろなやり方があるでしょうが、まず、gethostbyname() で、HOST名として検索し、失敗したら
gethostbyaddr()で、ＩＰアドレスとして検索します。両方失敗したらエラーとします。

<H4>【例】</H4>
<PRE>
  hostp = <FONT COLOR="#ff0080">gethostbyname</FONT>(hostnm);

  if (hostp == (struct hostent *)NULL){  <FONT COLOR="#008080">/* 失敗？ */</FONT>
    inaddr = <FONT COLOR="#ff0080">inet_addr</FONT>(hostnm); 		 <FONT COLOR="#008080">/*ＩＰアドレスに変換 */</FONT>
    hostp  = <FONT COLOR="#ff0080">gethostbyaddr</FONT>((char *)&AMP;inaddr,4,AF_INET);
      if (hostp == (struct hostent *)NULL){
        <FONT COLOR="#008080">/* 両方失敗はエラー */</FONT>
        exit(-1);
      }
  }
</PRE>

<P>上記のサンプルでは、ホスト名またはＩＰアドレスで、名前引きが出来る事が前提となります。

<P>名前引き出来ないアドレスを TCP で使用すると言った発想が私にはなかったのですが、ＰＣのダイアルアップ
ユーザーなどは、DNSをプロバイダーに向けていると、名前引きで電話を掛けにいってしまうそうです。

<P>もし名前引きしたくない場合は、 inaddr = inet_addr(hostnm); で戻り値 inaddr をチェックするだけにし、
正しくないＩＰアドレスならば<FONT COLOR="#ff0080">-1</FONT> が戻りますので、その後、gethostbyname()を実行すると
よいでしょう。


<DT><P><HR>

<DT><H4>【質問】</H4>
<DD>ＴＣＰソケットで接続相手のＩＰアドレスを調べたいのですが、どのように行えばよいのでしょうか？

<DT><H4>【回答】</H4>

<DD>getpeername()関数を使用して、接続中のソケットディスクリプターを渡すと、接続相手のＩＰとＰＯＲＴ番号が
わかります。

<H4>【例】</H4>
<PRE>
  if((rc = <FONT COLOR="#ff0080">getpeername</FONT>(sd,(struct sockaddr *)&AMP;saddr,&AMP;saddrlen)) < 0){
    perror("getpeername() failed");
    exit(-1);
  }
</PRE>
<DT><P><HR>

<DT><H4>【質問】</H4>
<DD>サーバーのプログラムを再立上げしたところ、正常に bind() 出来ずにエラーとなってしまいました。

<DT><H4>【回答】</H4>
<DD>前回 bind() していた port がクローズ出来ていないと思われます。netstat コマンドを利用して、
該当の port 番号を削除してから、立上げ直して下さい。
また、socket 作成時に setsockopt()にて、SO_REUSEADDR オプションを付けておくと、回避できるかもしれません。

<H4>【例】</H4>
<PRE>

int        sd;
int        on = 1;
int        rc;

      /* SO_REUSEADDR  */
      if ((rc = setsockopt(sd, SOL_SOCKET,
                           SO_REUSEADDR,
                           (char *)&AMP;on,
                           sizeof(on))) < 0)
      {
        perror("setsockopt() SO_REUSEADDR failed");
        exit(-1);
      }
</PRE>
<DT><P><HR>

<DT><H4>【質問】</H4>
<DD>ＴＣＰソケットの終了はどのように行えばよいのでしょうか？

<DT><H4>【回答】</H4>
<DD>ＴＣＰソケットの通信は全二重のため、通信の両サイドにて、close() を発行する必要があります。
close() は自分がもうこれ以上送信するデータがない場合に発行しますが、close() 発行後も相手はまだ送信可能状態です。
<P>セッション切断の手順がおかしいと、TCP コネクションの状態が、TIME_WAIT (時間待機）以外のステータスとなり、実際の
PORT クローズの時間が長くなってしまいます。
<DT><P><HR>

<DT><H4>【質問】</H4>
<DD>相手側のソケットが閉じられたことをどうやって知ることができますか?

<DT><H4>【回答】</H4>
<DD>read() / recv() は、0 を戻すでしょう。write() / send() は、その呼び出しは成功する事があるかも知れませんが、少なくとも、
その次の呼出しで EPIPE が帰るでしょう。
<DT><P><HR>

<DT><H4>【質問】</H4>
<DD>セッション確立後に相手がダウンしたのを検出できますか？

<DT><H4>【回答】</H4>
<DD>TCPIP 通信は SNAなどの様にセッション確立後もポーリングなどで状況を確認はしません。
送るべきデータがない場合、TCP セッション上に流れるパケットはありません。
そのためデータ通信中でないセッションは、相手がダウンしていても気がつきません。

<P>つまり、read()/recv()でブロックしている場合に、単に相手がデータを送ってこないのか、あるいは、ダウンしたのか
知ることができません。

<P>相手のダウンを知る方法の一つは、SO_KEEPALIVE オプションを設定することです。だだし、ＡＳ／４００のデフォルトは
120分に設定されています。デフォルトの値を変更することも可能ですが、TCP通信全体に影響してしまうので、
システム・デフォルトの設定変更には、十分注意してください。できるだけ、socket オプションで、SO_KEEPALIVE を設定
した方が無難でしょう。

<P>もう一つの方法は、プログラムでソケットをノンブロックに設定し、select 関数などで TIMEOUT を実装することです。
相手から、一定の時間応答がない場合は、相手かダウンしたものとして close()をしてしまう方法です。
一定時間の判断は、通信に要する時間＋相手がデータを作成する時間 などを考慮して、最適な時間としてください。

<P>write()/send()の場合は、簡単です。相手が ack を帰さないので、再送タイムアウト後に、関数呼出しが失敗するでしょう。
だだし、この再送タイムアウトは、数分を必要とするのが普通です。
<DT><P><HR>

<DT><H4>【質問】</H4>
<DD>数バイトのデータを送信するだけなのに、非常に時間がかかってしまいます。

<DT><H4>【回答】</H4>
<DD>多くの場合、write()/send() したデータは、TCP バケットとなって、実際にLANセグメントに送出されるでしょう。
しかし、TCPの場合は、このセグメントへの送り出しが即時である保証はありませんし、bufferの送り出しを強制すること
もできません。（SNA の場合は、Buffer FLASH する命令がありますし、Confirm などの処理では必ず Bufferの送り出しが
行われます。）

<P>ソケットへの書き出しは、いったん Buffer 置かれ Buffer 上のデータをいつ伝送するかは TCPIP が決めます。

<P>Bufferの送り出しの強制は不可能ですが、事前に TCP_NODELAY オプションを設定して TCP に対して遅延なく
パケットを送りだす様に指示することが可能です。多くの場合は、このオプションの設定により、問題は解決
するでしょう。


<DT><P><HR>

<DT><H4>【質問】</H4>
<DD>read() と recv() の違いは何ですか? 

<DT><H4>【回答】</H4>
<DD>read() 関数は、ファイルまたはソケットからデータを受信する場合に使用します。
<DD>recv() 関数は、ソケットを介してデータを受信する場合に使用します。

<P>つまり、recv() はソケット専用であり、flagsの指定が可能ですが、read() はファイルの読み込みにも使用出来ます。
<P>インクルードファイルも read() は &LT;unistd.h&GT; なのに対し、recv() は &LT;sys/socket.h&GT; です。

<P>recv()関数で指定可能なflags
<UL>
<LI>MSG_OOB<BR>帯域外データを受信します。

<LI>MSG_PEEK<BR>ソケットからメッセージを除去せずに、メッセージのコピーを獲得します。
</UL>

<CENTER>

</DL>

<HR>
<!------------------------------------------------------------------------------------->
<A HREF="../index.html">[Return]</A><BR>
</CENTER>

</BODY>
</HTML>
