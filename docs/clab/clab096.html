<HTML>
<HEAD>
<TITLE>CLab_09-実行環境</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<CENTER>
<TABLE BORDER=0" WIDTH="600" BGCOLOR="#FEFBDA">
<TR>
<TD>
<TABLE BORDER=0" WIDTH="600">
<TR>
<TD BGCOLOR="#800040" WIDTH="10%" ALIGN="CENTER">
<FONT SIZE=2 COLOR="#FFFFFF"><B>第9章</B></FONT>
</TD>
<TD BGCOLOR="000000" WIDTH="75%">
<FONT SIZE=4 COLOR ="#FFFFFF"><B>　スレッド</B></FONT>
<BR>
</TD>
<TD BGCOLOR="000000" WIDTH="15%">
<FONT SIZE=1 COLOR ="#FFFFFF"><B>RPGプログラマーの為のＣ言語講座</B></FONT>
</TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
<TABLE BORDER=0" WIDTH="570">
<TR>
<TD>
<FONT SIZE=2>

<P><B><FONT SIZE="+2" COLOR="#008000">ＯＳ／４００もＶ４２０からスレッドをサポートするようになりました。</FONT>

<P><FONT SIZE="+1" COLOR="#008000">Ｖ４２０はまだ実行環境だけで、Ｃで開発するには足りないものがあります。</FONT><BR>
<FONT SIZE="-1" COLOR="#0000FF"><B>*足りない物っていうのは、ヘッダーファイル（pthread.h）です。</B></FONT>

<P><FONT COLOR="#008000">Ｖ４３０になってやっと普通にスレッドでプログラミングが出来るようになりました。</FONT><BR>
<FONT SIZE="-1"COLOR="#0000FF">QSYSINCライブラリーにpthred.hが含まれています</FONT>
</B>

<P><FONT COLOR="#008000"><B>現在のところ、ＡＳ／４００でスレッドを利用できるのは、ＪＡＶＡ、ＩＬＥ−Ｃ，Ｃ＋＋です。
ＯＳサポートなので将来的にはもっと増えると思われます</B></FONT>
<P>
<P>Ｖ４２０以前は、ＯＳ／４００はスレッドをサポートしていませんでしたが、<BR>
ＯＳのオプションの<FONT COLOR="#ff80ff"><B>ＣＰＡ　ＴＯＯＬＫＩＴ</B></FONT>を導入すると、一応スレッド環境を<BR>
<FONT COLOR="#ff80ff"><B>エミュレート</B></FONT>ができました。

<P><FONT COLOR="#ff00ff">ＣＰＡ</FONT>では、実行単位はあくまでも<B><FONT COLOR="#ff80ff">ＪＯＢのまま</FONT></B>であり、スレッド実行分だけＪＯＢがサブシステムに上がってきていました。
<P><FONT COLOR="#ff00ff">ＣＰＡ</FONT>は、ユーザーのmain関数を書き換えて、user_main関数に変更し、自分がmainとして
ＯＳ／４００からの呼び出しを受けてからuser_mainを動かしています。
ＰＧＭからのスレッド生成の要求を受けてＪＯＢを動かし、ＪＯＢからのｉ／ｏを<FONT COLOR="#ff00ff">ＣＰＡ</FONT>がキャプチャーして、大元のＰＧＭ（thread_main)に戻していました。
<P>つまりＪＯＢ間のやり取りを<FONT COLOR="#ff00ff">ＣＰＡ</FONT>が行うことでスレッドらしい振る舞いに見せていました。
<BR>
<P>これに対し、Ｖ４２０では、ＷＲＫＪＯＢの中にスレッドを表示するオプションが追加されています。
<P><FONT COLOR="#008000"><B>プロセスがＪＯＢとするなら、ＪＯＢの中にスレッドを実装するのがやはり自然です。</B></FONT>
<P>ネイティブＤｏｍｉｎｏは、スレッドをバンバン使って動きますが非常に安定しています。
<P>ＣＰＡが前提だった、ＤＣＥ／４００とはえらい違いです。やっぱＯＳサポートは強いですね！
<BR>
<P><B><FONT SIZE="+2" COLOR="#008000">前置きがかなり長くなりましたが、そもそもスレッドって言うのは何でしょう。</FONT></B>
<BR>
<UL><B>
<P>ＲＰＧでは、内部サブルーチン（ＥＸＳＲ）の呼びたしをサポートしています。
<P>ＥＸＳＲよ呼ばれたサブルーチンはＢＥＧＳＲからＥＮＤＳＲまでを実行して呼び出した
ステップに戻ってきます。
<P>この際、ＥＸＳＲしたステップ次のステップは実行されずにＥＸＳＲしたサブルーチンの戻りを
待っています。
<P><FONT COLOR="#ff00ff">スレッドは、これを待たずに次のステップが実行出来るもの</FONT>って言うのがイメージ的に一番近いかと思います。
<P>ＥＸＳＲでサブルーチンを複数同時に実行でき、各サブルーチンが平行処理でき、呼びたし元は、あるサブルーチン
の実行の完了を待つこともできる。
<P>サブルーチンなので、変数，ｏｐｅｎしたファイル、配列などは全部共通で使用でき、処理は並列で進めることが
できる。
</B>
</UL>
<P><FONT COLOR="#ff00ff"><B>これがスレッドのイメージに一番近い形だと思います。</B></FONT>
<BR>
<P><FONT SIZE="+1" COLOR="#0000FF"><B>たとえば、</B></FONT>

<P>ＲＰＧで、長時間の検索処理を行うことを考えてください。
<P>ＤＳＰＦから検索条件をいれ、検索を実行する場合は、画面のＩ／Ｏは出来ません。
<P>しかし、アプリケーション上、画面に、検索の状況を表示したり、途中キャンセルを入力したりしたい場合があると思います。

<P>スレッドサポートのないときには、検索ループを何回か繰り返す合間に、画面のＩ／Ｏをするようにコーディングする方法で対応したりしていたのではないでしょうか？
<P>この場合、画面のＩ／Ｏ中は、<FONT COLOR="#ff00ff"><B>当然ＤＢの検索処理は止まってしまいます。</B></FONT>
<BR>

<P><B><FONT COLOR="#FF00FF">スレッドを使用すれば、ＤＢの検索をスレッドにさせておいて、自分はそのまま画面Ｉ／Ｏを行うことが
可能です。</FONT>
</B>ＤＢ検索処理は、画面Ｉ／Ｏによる遅延なく処理でき、かつ、スレッドでのＤＢ検索中に
次のＤＢ検索スレッドをスタートさせることも可能です。

<P><FONT SIZE="+2" COLOR="#008000">結構便利だと思いませんか？</FONT>

<P>でも、この程度だと、検索のＪＯＢをサブミットすれば、または、子プロセス実行すれば、一見同じ処理が
出来そうな気がしますね、便利だけど、どうしても、スレッドじゃなきゃって気はまだしませんね。

<P>では、検索処理の実行状況を画面に表示しながら、かつ、次の検索を平行して実行でき、その状況も画面に
表示したいって場合は、どうでしょうか？

<P>複数のＪＯＢ／プロセスから、1つの画面にＩ／Ｏするっていうのは、非常に難しいでしょう。
でもスレッドは、サブルーチンライクですから、単純にスレッドから画面に出力をするだけで
うまくいくはずです。もちろん、各スレッド毎のロックの処理はひつようですが...

</FONT>
</TD></TR>
</TABLE>

<HR>
</TD></TR>
</TABLE>

</BODY>
</HTML>

