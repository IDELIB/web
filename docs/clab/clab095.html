<HTML>
<HEAD>
<TITLE>CLab_09-実行環境</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<CENTER>
<TABLE BORDER=0" WIDTH="600" BGCOLOR="#FEFBDA">
<TR>
<TD>
<TABLE BORDER=0" WIDTH="600">
<TR>
<TD BGCOLOR="#800040" WIDTH="10%" ALIGN="CENTER">
<FONT SIZE=2 COLOR="#FFFFFF"><B>第9章</B></FONT>
</TD>
<TD BGCOLOR="000000" WIDTH="75%">
<FONT SIZE=4 COLOR ="#FFFFFF"><B>　プロセス</B></FONT>
<BR>
</TD>
<TD BGCOLOR="000000" WIDTH="15%">
<FONT SIZE=1 COLOR ="#FFFFFF"><B>RPGプログラマーの為のＣ言語講座</B></FONT>
</TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
<TABLE BORDER=0" WIDTH="570">
<TR>
<TD>
<FONT SIZE=2>

<P>少し、Ｃの話題とは離れてしまいますが、プロセスについて簡単に説明したいと思います。
<P>プロセスは、Ｕｎｉｘ系（ＷＩＮＤＷＯＳ−ＮＴ）で一般的に使用される実行単位です。

<P>ＯＳ／４００でプロセスに対応するものは、ＡＳ／４００ではＪＯＢと考えて良いでしょう。<BR>
しかし、両者の実行管理はかなり異なっています。<BR>
共通する項目は、ＣＰＵタイムスライス、実行優先順位、ぐらいでしょうか？<BR>
それぐらい、両者はちがいます。

<P>起動の方法ですが、ＡＳ／４００は、ＳＢＭＪＯＢｏｒサインオンでＪＯＢが起動します<BR>
<UL>
バッチＪＯＢの場合は、まずＪＯＢはＪＯＢＱに入れられて、ＪＯＢＤをみて、経路指定され、ＩＮＬＰＧＭが
動き、と言ったステップをふんでから、ＪＯＢが活動状態になります。
すべてのＪＯＢは、ＡＳ／４００のサブシステムの元に実行状態にされＯＳのサービスをうけます。
</UL>

<P>これに対し、Ｕｎｉｘでは、すでに実行中のプロセスが、自分自身の分身を作り、その分身自身が自分で
自分の環境を作成します。<BR>
ですから、Ｕｎｉｘの場合は、プロセスをたどると、最初のプロセスＩＮＩＴＴＡＢに行き着きます。

<P><FONT SIZE="+1" COLOR="#0000FF">たとえて言えば、</FONT>

<P>プロセスは、自分のクローン人間を作るようなもので、誕生したときから、自分と同い年で、
自分と同じ経験、能力をもっています。クローンが、オリジナルと違う人生を歩むには、自分自身で、
自分を作り変える必要があります。

<P>これに対しＪＯＢは、生まれた時には、まっさらな状態です。親に仕込まれたＪＯＢは、時が来るとＪＯＢＱより
外にでて、ＯＳの手厚いサービスを受けながら、一人前になっていきます。ＯＳはＪＯＢごとにどういう育て方を
すればよいか、ＪＯＢＤより読み取り、そのとおりに、ＪＯＢを一人前に育てます。
ですから、ＪＯＢが親からそのまま受け継ぐものは、ほとんどありません。
</B>

<P><FONT COLOR="#FF00FF">なぜ、こんなにも違うのでしょうか？</FONT>

<P><B>ここからは、私の勝手な思いこみですので気にしないでください。</B>

<P>ＯＳ／４００はご存じの通り大変にきれいなアーキテクチャーを誇っています。

<P>AS/400 
<TABLE BORDER WIDTH="580" HEIGHT="300" BGCOLOR="#00ff00">
<TR>
<TD WIDTH=20% >ＲＰＧ中間コード</TD>
<TD WIDTH=80%  BORDER=0 >ＪＡＶＡで言うところのバイトコード<BR>
ＲＰＧに限らず属性が*PGMのものはすべてバイトコードの表現</TD>
</TR>

<TR>
<TD WIDTH=20% >ＯＳ／４００</TD>
<TD WIDTH=80%  BORDER=0 >ＯＳサービス</TD>
</TR>

<TR>
<TD WIDTH=20% >ＭＩ</TD>
<TD WIDTH=80%  BORDER=0 >ＭＩ命令を処理するインタープリター</TD>
</TR>

<TR>
<TD WIDTH=20% >マイクロコード</TD>
<TD WIDTH=80%  BORDER=0 >ハードウェアの制御</TD>
</TR>

<TR>
<TD WIDTH=20% >Ｈ／Ｗ</TD>
<TD WIDTH=80%  BORDER=0 >実際のハードウェア</TD>
</TR>

</TABLE></FONT>

<P>これに対しＵＮＩＸはシンプルです
<TABLE BORDER WIDTH="580" HEIGHT="300" BGCOLOR="#FFFF80">
<TR>
<TD WIDTH=20% >ユーサーモード</TD>
<TD WIDTH=80%  BORDER=0 >ユーザーに与えられた空間で稼働する</TD>
</TR>

<TR>
<TD WIDTH=20% >カーネルモード</TD>
<TD WIDTH=80%  BORDER=0 >カーネル (ＯＳ) のみアクセス可能な領域にアクセスする</TD>
</TR>

<TR>
<TD WIDTH=20% >Ｈ／Ｗ</TD>
<TD WIDTH=80%  BORDER=0 >実際のハードウェア</TD>
</TR>
</TABLE></FONT>

<P>UNIXでは、プロセスの実行に関して、ＯＳが初期処理であまりＣＰＵを使いたくないので、<FONT SIZE="-1" COLOR="#FF00FF">(本当かなぁ〜)</FONT>すでに動いているプロセスを丸ごとコピーすることで、プロセス生成処理を軽くしています。

<P>コピーされたプロセスは、親プロセスと同じステップから、すぐに実行が始まります。

<P><UL>
このような構造にしているのは、ユーザープロセスにカーネル部分をなるべくアクセスできないようにしたいっていうのも理由にあると思います。自分をコピーするだけの機能しか提供していなければ、ユーザーからカーネルにアクセスする範囲は限定されたものになります。自分以外の領域に対する変更は、基本的に許さないようにできます。コピーによって生成されたプロセスは、自分自身に割り当てられた領域のみを変更することで、新しいプロセスとして稼働することができます。
</UL>

<P>これに対しＡＳ／４００では、ＯＳのタスク、Ｈ／Ｗ、ユーザー環境などがアーキテクチャにしたがってきれいにレイヤーに分かれています。

<P>ＪＯＢの属性にしても、ＯＳ／４００の方が遥かに多くの項目についてＪＯＢ毎にＯＳが管理しています。

<P>その分、ＪＯＢの起動や、ロギング、その他管理タスクに使用されるワークロードにより、同じＣＰＵパワーだとしたら、処理自体はＡＳ／４００の方が遅くなります。

<P>だだし、今日の様にＣＰＵパワーがどんどん増強され、マルチＣＰＵや何ＧＢものメモリーが実装される様になってくると、ＪＯＢ毎にＯＳが
しっかりとした管理をしているＡＳ／４００の方が断然有利となります。

<P>いかに、少ない限られたＣＰＵパワーを有効に使うべきかって発想から、有り余るＣＰＵパワーをどうやって使い切るかって発想に変わってきていると言えるのではないでしょうか？

</FONT>
</TD></TR>
</TABLE>

<HR>
</TD></TR>
</TABLE>

</BODY>
</HTML>

