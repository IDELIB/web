<HTML>
<HEAD>
<TITLE>CLab_11-CLAB sokcet</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#800000" VLINK="#008000" ALINK="#FF00FF">
<CENTER>
<TABLE BORDER=0" WIDTH="600" BGCOLOR="#FEFBDA">
<TR>
<TD>
<TABLE BORDER=0" WIDTH="600">
<TR>
<TD BGCOLOR="#800040" WIDTH="10%" ALIGN="CENTER">
<FONT SIZE=2 COLOR="#FFFFFF"><B>第11章</B></FONT>
</TD>
<TD BGCOLOR="000000" WIDTH="75%">
<FONT SIZE=4 COLOR ="#FFFFFF"><B>　ＲＰＧを使ったサーバープログラム</B></FONT>
<BR>
</TD>
<TD BGCOLOR="000000" WIDTH="15%">
<FONT SIZE=1 COLOR ="#FFFFFF"><B>RPGプログラマーの為のＣ言語講座</B></FONT>
</TD>
</TR>
</TABLE>
</TD>
</TR>
<TR>
<TD ALIGN="CENTER">
<TABLE BORDER=0" WIDTH="570">
<TR>
<TD>
<FONT SIZE=2>
<BR>
<H3>ソケット通信を行うサーバープログラムは通常デーモンとして動作します。</H3>

<P>サーバーデーモンは通常、接続をまつ親プロセスがいて、クライアントとからの接続要求を処理し、
クライアントと接続したあとの実際のデータ処理部分は、子プロセスを起動してそちらにまかせ、
自分は、次のクライアント接続要求に備えるという動きをします。

<P>この機能のサポートの為、よく使用されるのは、プロセスまたはスレッドです。

<P>しかし、残念ながらＲＰＧでは、上記のいずれの機構もサポートしていません。

<P>そのため、前項のサンプルプログラム(SOKRPGSVR)では、１つのサーバーＰＧＭ当たり１つのクライアント
しかサポート出来ませんでした。（１クライアントが接続すると、LISTENポートをクローズして、クライアント
との通信を処理するようになっています。このようなプログラムのロジックでは、次のクライアントも接続
出来るようにするためには、別途サーバーＰＧＭを実行する必要があります。）

<P>ＲＰＧでは、ＲＰＧ内でＣＡＬＬで呼びだしを行うと、そのＰＧＭがリターンするまで、呼び出し元のＲＰＧ
の実行は止まってしまいます。これでは、次のクライアントの接続要求を処理することはできません。
<P>ＳＢＭＪＯＢでバッチＪＯＢとして投入する方法も考えられますが、この方法だと、たしかに、実行は並列が
可能ですが、バッチＪＯＢは、独自のＪＯＢとして起動されるため、ソケットの接続をそのバッチＪＯＢに
渡す方法が難しくなってしまいます。

<P><FONT SIZE=3 COLOR="#ff8080"><H3>ＲＰＧでの解決策は？</H3></FONT>

<OL>
	<LI><B>ＲＰＧからプロセスサポートのプログラムを呼び出す</B><BR>
	子プロセス起動するためのＣのプログラムを作成し、ＲＰＧからコールする。<BR>
	起動する子プロセスでは、まずＣのプログラムが動き、そのプログラムより、指定された
	ＲＰＧを起動する。プロセス間のコントロールなどは、中間に位置するＣのプログラムで
	行い、ＲＰＧでは考慮しなくてよいようにする。<BR><BR>

	<LI><B>ＲＰＧからスレッドサポートのプログラムを呼び出す</B><BR>
	スレッド起動するためのＣのプログラムを作成し、ＲＰＧからコールする。<BR>
	起動するスレッドではでは、まずＣのプログラムが動き、そのプログラムより、指定された
	ＲＰＧを起動する。だだし、この方法を取る場合、ＲＰＧ自体もスレッドセーフな処理を
	考慮する必要があると考えられる。<BR><BR>
	
	<LI><B>異なるＪＯＢ間で、ソケットディスクリプターを渡せるようにする</B><BR>
	Takedescriptor()/Givedescriptor()を使用して、ＪＯＢ間でソケットディスクリプターを受け渡す<BR>
	ただし、この関数が、相手のJOBIDを必要とするため、単純なCALLだけでは処理ができない。<BR><BR>
	
</B></OL>

が考えられます。
<P>今回は、ＲＰＧでの考慮をできるだけしたくないので、<BR>
<H3>１．ＲＰＧからプロセスサポートのプログラムを呼び出す</H3>
方法で実装したいと思います。

<P ALIGN=CENTER>それでは、まずプロセスを呼び出すＣのプログラムを用意しましょう

<TABLE BGCOLOR=#FFE0FF ALIGN=CENTER WIDTH="70%" BORDER=2 CELLSPACING=1 CELLPADDING=2>
<TR ALIGN=CENTER><TD>プロセス関数</TD><TD>Ｃのプログラム名</TD><TD>　説　明　</TD></TR>
<TR><TD>spawn()	</TD>	<TD>SKSPWN</TD>	<TD>子プロセスの生成</TD></TR>
<TR><TD> ..		</TD>	<TD>SKCHLD</TD>	<TD>子プロセス実行</TD></TR>
</TABLE>

<B><P><FONT SIZE="4" COLOR="#004080"><P>上記のＰＧＭは<A HREF="../sokrpg/sokrpg.html">Socket RPG</A>として、一つのパッケージにまとめました。
</FONT></B>

<P><FONT SIZE=3 COLOR="#ff00ff"><B>それでは実際に、これらのプログラムを利用して、
ＲＰＧによるサーバーデーモン型ソケット通信のプログラムを作成してみましょう</B></FONT>

<P>作成するサンプルのＲＰＧは、以下の様なプログラムとします。

<TABLE BGCOLOR="#E0FFDF" WIDTH=95% BORDER=1 ALIGN=CENTER>
<TR ALIGN=CENTER>
	<TD><A HREF="./text/sokrpgud.txt">サーバーデーモンＲＰＧ</A></TD>
	<TD><A HREF="./text/sokrpgca.txt">クライアントＲＰＧ</A></TD>
</TR>
<TR>
	<TD><H4>１．ソケットのオープン</H4>
<FONT SIZE=2>SKOPENプログラムによりソケットをオープンします。SKOPENでは、setsocketオプションで、
TCP_NODELAY,SO_REUSEADDRをセットしています。</FONT>
	</TD>
	<TD><H4>１．ソケットのオープン</H4>
<FONT SIZE=2>SKOPENプログラムによりソケットをオープンします。SKOPENでは、setsocketオプションで、
TCP_NODELAY,SO_REUSEADDRをセットしています。</FONT>
	</TD>
</TR>
<TR>
	<TD><H4>２．バインド</H4>
<FONT SIZE=2>SKBINDプログラムによりソケットにＩＰアドレス／ポート番号を割り当てます。
SKBINDでは、明示的なＩＰ割り当ての代わりにＡＮＹとしてどのインターフェースからの
接続要求についても受けとれります。</FONT>
	</TD>
	<TD>なし</TD>
</TR>
<TR>
	<TD><H4>３．リッスン</H4>
<FONT SIZE=2>SKLISNプログラムにより、クライアントからの接続要求の受け入れ準備をします。
</FONT>
	</TD>
	<TD>なし</TD>
</TR>
<TR>
	<TD>なし</TD>
	<TD><H4>４．コネクト</H4>
<FONT SIZE=2>SKCONNプログラムにより、サーバーに接続を行います。ＩＰアドレスは、
構内ループバックアドレス（１２７．０．０．１）を指定しているので、サーバーと同じマシン上で
クライアントも実行すると仮定しています。</FONT>
	</TD>
</TR>
<TR>
	<TD><H4>５．アクセプト</H4>
<FONT SIZE=2>SKACPTプログラムにより、クライアントからの接続要求を受け入れます。<BR>
この際に、新しいソケットディスクリプターがシステムにより与えられます。これ以降の通信は
ここで割り当てられた新しいディスクリプターを使用します。
</FONT>
	</TD>
	<TD>なし</TD>
</TR>

<TR>
	<TD><H4>６．子プロセス作成</H4>
<FONT SIZE=2>SKSPWNプログラムにより、パラメーターに子プロセスプログラム(SOKRPGUP)と
５．アクセプトで入手したソケットデイスクリプターを指定し、子プロセスを起動します。<BR>
<H4><CENTER>”５．アクセプトへ戻る”</CENTER></H4>
</FONT>
	</TD>
	<TD>なし</TD>
</TR>

<TR>
	<TD BGCOLOR="#FFFFA1" ALIGN=CENTER><A HREF="./text/sokrpgup.txt">子プロセスＲＰＧ</A></TD>
	<TD>なし</TD>
</TR>

<TR>
	<TD BGCOLOR="#FFFFA1"><H4>７．子プロセス起動</H4>
<FONT SIZE=2>SKSPWNにより呼び出されたSKCHLDプログラムからRPG(SOKRPGUP)が起動されます。<BR>
ＲＰＧは、SKCHLDプログラムからソケットディスクリプターをパラメーターとして受け取ります。<BR>
	</TD>
	<TD>なし</TD>
</TR>

<TR>
	<TD BGCOLOR="#FFFFA1"><H4>８．データ受信</H4>
<FONT SIZE=2>SKRECVプログラムを使用し、クライアントから送信された文字列を受信します<BR>
</FONT>
	</TD>
	<TD><H4>８．データ送信</H4>
<FONT SIZE=2>SKSENDプログラムにより、画面から入力された文字列を送信します。<BR>
</FONT>
	</TD>
</TR>
<TR>
	<TD BGCOLOR="#FFFFA1"><H4>９．データ送信</H4>
<FONT SIZE=2>SKSENDプログラムにより、８．でクライアントから受信した文字列をそのまま送信します。<BR>
（エコー処理）
</FONT>
	</TD>
	<TD><H4>９．データ受信</H4>
<FONT SIZE=2>SKRECVプログラムにより、サーバーから送信された文字列を受信し、画面表示します。<BR>
（エコー処理）
</FONT>
	</TD>
</TR>
<TR>
	<TD BGCOLOR="#FFFFA1"><H4>１０．ソケットクローズ</H4>
<FONT SIZE=2>文字列［EXIT]が送られてきた場合は、SKCLOSプログラムにより、ソケットのクローズを行います。
</FONT>
	</TD>
	<TD><H4>１０．ソケットクローズ</H4>
<FONT SIZE=2>画面からＦ３が押されるか、サーバープログラムが終了した場合は、SKCLOSプログラムにより、ソケットのクローズを行います。
</FONT>
	</TD>
</TR>
</TABLE>

<CENTER>
<P><FONT SIZE=3 COLOR="#ff80ff"><B>上記の３．５．６および８．９はＬＯＯＰするものとします。</B></FONT>
<P>複数のクライアント（ＳＯＫＲＰＧＣＡ）の実行が可能です。
<P>複数実行時にＷＲＫＡＣＴＪＯＢコマンドで状況をみると以下のようになります。
<IMG SRC="../sokrpg/sokrpgud.gif" ALT="sokrpgud.gifイメージ" HEIGHT=450 WIDTH=570>
<P>子プロセスのＪＯＢタイプは、ＢＣＩとなるため、子プロセスのＲＰＧでは、
対話型の機能は使用できません。つまり、画面を出したりといった対話型の機能はサポートしません。

</CENTER>

</FONT>
</TD>
</TR>
</TABLE>
</CENTER>

</FONT>
</TD></TR>
</TABLE>

<HR>
</TD></TR>
</TABLE>

</BODY>
</HTML>


